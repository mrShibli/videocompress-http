package main

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"html/template"
	"io"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"time"
)

// ======================
// Config
// ======================

const (
	maxUploadSize = 2 << 30 // 2 GB
	tmpKeep       = 30 * time.Minute
)

// ======================
// Helpers
// ======================

func envOr(k, def string) string {
	if v := os.Getenv(k); v != "" {
		return v
	}
	return def
}

func withExt(p, newExt string) string {
	base := strings.TrimSuffix(filepath.Base(p), filepath.Ext(p))
	return filepath.Join(filepath.Dir(p), base+newExt)
}

func randID(n int) string {
	b := make([]byte, n)
	_, _ = rand.Read(b)
	return hex.EncodeToString(b)
}

func humanBytes(n int64) string {
	const k = 1024.0
	f := float64(n)
	switch {
	case f >= k*k*k:
		return fmt.Sprintf("%.2f GB", f/(k*k*k))
	case f >= k*k:
		return fmt.Sprintf("%.2f MB", f/(k*k))
	case f >= k:
		return fmt.Sprintf("%.2f KB", f/k)
	default:
		return fmt.Sprintf("%d B", n)
	}
}

// ======================
// Encoding options + logic
// ======================

type compressOpts struct {
	Codec      string        // h264|h265|copy
	CRF        int           // CPU encoders quality
	Preset     string        // ultrafast..placebo (CPU encoders)
	Scale      string        // e.g. 1280:-2 or 1920:1080
	FPS        int           // force output fps if >0
	Audio      string        // aac|opus|copy
	AB         string        // audio bitrate (e.g. 128k)
	HW         string        // videotoolbox|none
	OutExt     string        // .mp4 (recommended)
	Timeout    time.Duration // overall job timeout
	SpeedMode  string        // ultra_fast|super_fast|fast|balanced|quality|ai|max|turbo
	Resolution string        // 360p|480p|720p|1080p|1440p|2160p|original
	TargetSecs int           // AI time budget in seconds (default 120)
}

func (o *compressOpts) normalize() {
	if o.Codec == "" {
		o.Codec = "h264"
	}
	if o.Audio == "" {
		o.Audio = "aac"
	}
	if o.AB == "" {
		o.AB = "128k"
	}
	if o.HW == "" {
		o.HW = "none" // VPS-safe default
	}
	if o.OutExt == "" {
		o.OutExt = ".mp4"
	}
	if o.Timeout == 0 {
		o.Timeout = 45 * time.Minute
	}
	if o.SpeedMode == "" {
		o.SpeedMode = "ai"
	}
	if o.Resolution == "" {
		o.Resolution = "original"
	}
	if o.TargetSecs <= 0 {
		o.TargetSecs = 120 // 2 minutes
	}
	o.applyResolution()
}

// duration-aware probe (ffprobe)
func probeDuration(path string) float64 {
	out, err := exec.Command("ffprobe",
		"-v", "error",
		"-show_entries", "format=duration",
		"-of", "default=noprint_wrappers=1:nokey=1",
		path,
	).Output()
	if err != nil {
		return 0
	}
	dur, _ := strconv.ParseFloat(strings.TrimSpace(string(out)), 64)
	if dur < 0 {
		return 0
	}
	return dur
}

func throughputMBps(speed string) float64 {
	switch speed {
	case "turbo":
		return 10.0 // softer turbo at 720p
	case "max":
		return 12.0
	case "ultra_fast":
		return 8.0
	case "super_fast":
		return 5.0
	case "fast":
		return 3.0
	case "balanced":
		return 2.0
	case "quality":
		return 1.2
	default:
		return 2.0
	}
}

// Estimate time by size & profile (seconds) — simple model
func estimateTimeSecs(sizeMB int64, speed string) int {
	t := throughputMBps(speed)
	if t <= 0 {
		t = 2.0
	}
	secs := float64(sizeMB) / t
	secs *= 1.12 // modest overhead
	return int(secs)
}

func chooseSpeedBySize(sizeMB int64) string {
	switch {
	case sizeMB >= 700:
		return "ultra_fast"
	case sizeMB >= 200:
		return "super_fast"
	case sizeMB >= 50:
		return "fast"
	case sizeMB >= 10:
		return "balanced"
	default:
		return "balanced"
	}
}

// Apply speed profile → CRF/Preset/AB
func (o *compressOpts) applySpeedMode() {
	switch o.SpeedMode {
	case "turbo":
		// Soft-fast turbo: 720p/24fps defaulted in build, AAC stereo
		o.CRF = 34
		o.Preset = "ultrafast"
		o.AB = "96k"
	case "max":
		o.CRF = 36
		o.Preset = "ultrafast"
		o.AB = "64k"
	case "ultra_fast":
		o.CRF = 32
		o.Preset = "ultrafast"
		o.AB = "96k"
	case "super_fast":
		o.CRF = 30
		o.Preset = "ultrafast"
		o.AB = "96k"
	case "fast":
		o.CRF = 28
		o.Preset = "veryfast"
		o.AB = "128k"
	case "quality":
		o.CRF = 23
		o.Preset = "fast"
		o.AB = "128k"
	default: // balanced
		if o.CRF == 0 {
			o.CRF = 26
		}
		if o.Preset == "" {
			o.Preset = "veryfast"
		}
	}
}

func (o *compressOpts) applyResolution() {
	switch o.Resolution {
	case "360p":
		o.Scale = "640:360"
	case "480p":
		o.Scale = "854:480"
	case "720p":
		o.Scale = "1280:720"
	case "1080p":
		o.Scale = "1920:1080"
	case "1440p":
		o.Scale = "2560:1440"
	case "2160p":
		o.Scale = "3840:2160"
	case "original":
		// keep original
	default:
		// unknown -> keep original
	}
}

// Extra safety for very small inputs
func (o *compressOpts) tinyInputSafety(fileSize int64) {
	sizeMB := fileSize / (1024 * 1024)
	if sizeMB < 10 {
		o.Codec = "h264"
		o.Audio = "aac"
		o.Scale = ""
		o.CRF = 22
		o.Preset = "veryfast"
		o.HW = "none"
	}
}

// ffmpeg args
func buildFFmpegArgs(inPath, outPath string, o compressOpts) []string {
	// Base flags; try HW decode on mac when enabled
	args := []string{"-y", "-hide_banner", "-loglevel", "error"}
	if strings.ToLower(o.HW) == "videotoolbox" {
		args = append(args, "-hwaccel", "videotoolbox", "-hwaccel_output_format", "videotoolbox")
	}
	args = append(args, "-i", inPath)

	// Turbo defaults: 720p @ 24fps if user didn't set them
	if o.SpeedMode == "turbo" {
		if o.Scale == "" && strings.ToLower(o.Codec) != "copy" {
			o.Scale = "1280:720"
		}
		if o.FPS == 0 {
			o.FPS = 24
		}
	}
	// Max defaults: 480p @ 24fps if user didn't set them
	if o.SpeedMode == "max" {
		if o.Scale == "" && strings.ToLower(o.Codec) != "copy" {
			o.Scale = "854:480"
		}
		if o.FPS == 0 {
			o.FPS = 24
		}
	}

	// scale
	if o.Scale != "" && strings.ToLower(o.Codec) != "copy" {
		args = append(args, "-vf", "scale="+o.Scale+":flags=fast_bilinear")
	}
	// fps (only if re-encoding video)
	if o.FPS > 0 && strings.ToLower(o.Codec) != "copy" {
		args = append(args, "-r", strconv.Itoa(o.FPS))
	}

	// codec
	vcodec := ""
	switch strings.ToLower(o.Codec) {
	case "copy":
		vcodec = "copy"
	case "h265":
		if strings.ToLower(o.HW) == "videotoolbox" {
			vcodec = "hevc_videotoolbox"
		} else {
			vcodec = "libx265"
		}
	default: // h264
		if strings.ToLower(o.HW) == "videotoolbox" {
			vcodec = "h264_videotoolbox"
		} else {
			vcodec = "libx264"
		}
	}

	if vcodec == "copy" {
		args = append(args, "-c:v", "copy")
	} else {
		args = append(args, "-c:v", vcodec)

		switch vcodec {
		case "libx264", "libx265":
			args = append(args, "-crf", strconv.Itoa(o.CRF), "-preset", o.Preset)
		case "h264_videotoolbox", "hevc_videotoolbox":
			// map CRF→bitrate for hardware encoders
			bitrate := "3M"
			switch {
			case o.CRF <= 20:
				bitrate = "5M"
			case o.CRF <= 23:
				bitrate = "4M"
			case o.CRF <= 26:
				bitrate = "3M"
			case o.CRF <= 30:
				bitrate = "2.5M"
			case o.CRF <= 36:
				bitrate = "2M"
			default:
				bitrate = "1500k"
			}
			// Turbo a bit higher for decent 720p
			if o.SpeedMode == "turbo" {
				bitrate = "2500k"
			}
			args = append(args, "-b:v", bitrate)
		}

		// browser compatibility
		if strings.ToLower(o.OutExt) == ".mp4" {
			args = append(args, "-pix_fmt", "yuv420p")
		}
	}

	// Extra accelerations (zero-latency style)
	if o.SpeedMode == "max" || o.SpeedMode == "turbo" {
		switch vcodec {
		case "libx264":
			args = append(args, "-tune", "fastdecode,zerolatency")
			args = append(args, "-g", "300", "-keyint_min", "300")
			args = append(args, "-x264-params",
				"no-scenecut=1:ref=1:bframes=0:me=dia:subme=0:trellis=0:aq-mode=0:fast_pskip=1:sync-lookahead=0:rc-lookahead=0")
		case "libx265":
			args = append(args, "-tune", "fastdecode")
			args = append(args, "-g", "300", "-keyint_min", "300")
		case "h264_videotoolbox", "hevc_videotoolbox":
			args = append(args, "-realtime", "true")
			args = append(args, "-g", "300")
		}
	}

	// audio
	switch strings.ToLower(o.Audio) {
	case "copy":
		args = append(args, "-c:a", "copy")
	case "opus":
		args = append(args, "-c:a", "libopus", "-b:a", o.AB)
	default:
		args = append(args, "-c:a", "aac", "-b:a", o.AB)
		// turbo: stereo 96k; max: mono 64k
		if o.SpeedMode == "turbo" {
			args = append(args, "-ac", "2")
			args = append(args, "-b:a", "96k")
		} else if o.SpeedMode == "max" {
			args = append(args, "-ac", "1")
			args = append(args, "-b:a", "64k")
		}
	}

	// faststart + threads
	args = append(args, "-movflags", "+faststart", "-threads", "0", outPath)
	return args
}

// run ffmpeg synchronously; if HW fails, retry CPU
func runFFmpeg(ctx context.Context, inPath, outPath string, o compressOpts, logWriter io.Writer) error {
	o.normalize()
	args := buildFFmpegArgs(inPath, outPath, o)

	cmd := exec.CommandContext(ctx, "ffmpeg", args...)
	cmd.Stdout = logWriter
	cmd.Stderr = logWriter
	err := cmd.Run()
	if err == nil {
		return nil
	}

	if strings.Contains(strings.ToLower(o.HW), "videotoolbox") {
		fmt.Fprintln(logWriter, "VideoToolbox failed; falling back to CPU.")
		o.HW = "none"
		args = buildFFmpegArgs(inPath, outPath, o)
		cmd = exec.CommandContext(ctx, "ffmpeg", args...)
		cmd.Stdout = logWriter
		cmd.Stderr = logWriter
		return cmd.Run()
	}
	return err
}

// ======================
// Result Store (for UI flow)
// ======================

type resultEntry struct {
	FilePath       string
	CreatedAt      time.Time
	ModeFinal      string
	ModeDecider    string // "ai" or "manual"
	InputBytes     int64
	InputDurationS float64
	OutputBytes    int64
	DurationMS     int64
	Resolution     string
	Codec          string
	Audio          string
	HW             string
	ThroughputMBs  float64
	TargetSecs     int
	EstimatedSecs  int
}

var (
	storeMu sync.Mutex
	store   = map[string]*resultEntry{}
)

// cleanup goroutine (optional; call once in main if you want)
func cleanupStore() {
	ticker := time.NewTicker(5 * time.Minute)
	defer ticker.Stop()
	for range ticker.C {
		now := time.Now()
		storeMu.Lock()
		for id, e := range store {
			if now.Sub(e.CreatedAt) > tmpKeep {
				_ = os.Remove(e.FilePath)
				delete(store, id)
			}
		}
		storeMu.Unlock()
	}
}

// ======================
//
// HTTP layer
//
// ======================

var uploadTpl = template.Must(template.New("u").Parse(`
<!doctype html>
<meta charset="utf-8">
<title>Video Compress</title>
<style>
body{font-family:ui-sans-serif,system-ui;margin:40px;max-width:900px;line-height:1.6}
.form-group{margin:12px 0}
label{display:block;margin-bottom:6px;font-weight:600}
input,select{width:100%;padding:8px;border:1px solid #d1d5db;border-radius:6px}
button{background:#111827;color:#fff;border:0;padding:12px 20px;border-radius:8px;cursor:pointer}
button:hover{background:#0f172a}
details{margin:12px 0}
pre{background:#f3f4f6;padding:12px;border-radius:6px;overflow:auto}
.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:8px}
.card{border:1px solid #e5e7eb;border-radius:8px;padding:8px}
card input{width:auto}
small{color:#6b7280}
.kv{display:grid;grid-template-columns:200px 1fr;gap:8px 16px}
kbd{background:#f3f4f6;border:1px solid #e5e7eb;border-radius:4px;padding:2px 6px}
</style>

<h1>Video Compress</h1>

<form method="post" action="/compress" enctype="multipart/form-data">
  <input type="hidden" name="ui" value="1">
  <div class="form-group">
    <label>Video file</label>
    <input type="file" name="file" accept="video/*" required>
  </div>

  <div class="grid">
    <div class="card">
      <label>Mode</label>
      <select name="speed">
        <option value="ai" selected>AI (auto by size & time)</option>
        <option value="turbo">TURBO (very fast, 720p)</option>
        <option value="max">MAX (very fast, 480p)</option>
        <option value="ultra_fast">Ultra Fast</option>
        <option value="super_fast">Super Fast</option>
        <option value="fast">Fast</option>
        <option value="balanced">Balanced</option>
        <option value="quality">Quality</option>
      </select>
      <small>AI respects your time budget; ≤10s → TURBO, ≤20s → MAX. Short clips (≤60s) avoid turbo/max.</small>
    </div>
    <div class="card">
      <label>Time budget (seconds)</label>
      <input style="width: 245px;" type="number" name="target_secs" value="120" min="5" step="5">
      <small>Applies to AI mode only.</small>
    </div>
    <div class="card">
      <label>Resolution</label>
      <select name="resolution">
        <option value="original" selected>Original</option>
        <option value="360p">360p</option>
        <option value="480p">480p</option>
        <option value="720p">720p</option>
        <option value="1080p">1080p</option>
        <option value="1440p">1440p</option>
        <option value="2160p">2160p</option>
      </select>
    </div>
  </div>

  <details>
    <summary>Advanced</summary>
    <div class="grid">
      <div class="card">
        <label>Video codec</label>
        <select name="codec">
          <option value="h264" selected>H.264</option>
          <option value="h265">H.265/HEVC</option>
          <option value="copy">Copy video stream</option>
        </select>
      </div>
      <div class="card">
        <label>Hardware</label>
        <select name="hw">
          <option value="none" selected>CPU only</option>
          <option value="videotoolbox">macOS VideoToolbox</option>
        </select>
      </div>
      <div class="card">
        <label>Audio codec</label>
        <select name="audio">
          <option value="aac" selected>AAC</option>
          <option value="opus">Opus</option>
          <option value="copy">Copy audio</option>
        </select>
      </div>
      <div class="card">
        <label>Output extension</label>
        <select name="outExt">
          <option value=".mp4" selected>.mp4</option>
          <option value=".mov">.mov</option>
        </select>
      </div>
    </div>
  </details>

  <button type="submit">Compress</button>
</form>

<h3>cURL (API, returns file bytes + headers)</h3>
<pre>
# AI 10s budget → TURBO (720p), but short clips (≤60s) avoid turbo/max
curl -f -S -o out.mp4 \
  -H "Accept: application/octet-stream" \
  -F "file=@input.mp4" \
  -F "speed=ai" \
  -F "target_secs=10" \
  http://localhost:8080/compress \
  -D headers.txt
</pre>
<p><small>See <kbd>headers.txt</kbd> → <kbd>X-*</kbd> metadata (mode, time, sizes, duration, throughput, target & estimate).</small></p>
`))

var resultTpl = template.Must(template.New("r").Parse(`
<!doctype html>
<meta charset="utf-8">
<title>Compression result</title>
<style>
body{font-family:ui-sans-serif,system-ui;margin:40px;max-width:900px;line-height:1.6}
h1{margin-top:0}
.kv{display:grid;grid-template-columns:240px 1fr;gap:8px 16px}
code{background:#f3f4f6;border-radius:4px;padding:2px 6px}
a.btn{display:inline-block;margin-top:16px;background:#111827;color:#fff;text-decoration:none;padding:12px 16px;border-radius:8px}
a.btn:hover{background:#0f172a}
pre{background:#f3f4f6;padding:12px;border-radius:6px;overflow:auto}
</style>

<h1>✅ Compression complete</h1>
<div class="kv">
  <div>Mode</div><div><code>{{.ModeFinal}}</code> <small>(decided by: {{.ModeDecider}})</small></div>
  <div>Time taken</div><div>{{printf "%.2f" .Seconds}} s</div>
  <div>Target time</div><div>{{.TargetSecs}} s</div>
  <div>Estimated time</div><div>{{.EstimatedSecs}} s</div>
  <div>Input duration</div><div>{{printf "%.2f" .InputDuration}} s</div>
  <div>Throughput</div><div>{{printf "%.2f" .Throughput}} MB/s</div>
  <div>Input size</div><div>{{.InputHuman}} ({{.InputBytes}} bytes)</div>
  <div>Output size</div><div>{{.OutputHuman}} ({{.OutputBytes}} bytes)</div>
  <div>Resolution</div><div>{{.Resolution}}</div>
  <div>Video codec</div><div>{{.Codec}}</div>
  <div>Audio codec</div><div>{{.Audio}}</div>
  <div>Hardware</div><div>{{.HW}}</div>
</div>

<a class="btn" href="/dl/{{.ID}}?name={{.SuggestName}}">⬇️ Download compressed file</a>

<h3>API example</h3>
<pre>
curl -f -S -o out.mp4 \
  -H "Accept: application/octet-stream" \
  -F "file=@input.mp4" \
  -F "speed={{.ModeDecider}}" \
  -F "target_secs={{.TargetSecs}}" \
  http://localhost:8080/compress \
  -D headers.txt

# X-Mode, X-Mode-Decider, X-Target-Secs, X-Estimated-Secs, X-Encode-Duration-Ms,
# X-Input-Bytes, X-Output-Bytes, X-Input-Duration-Secs, X-Throughput-MBps,
# X-Resolution, X-Video-Codec, X-Audio-Codec, X-HW
</pre>
`))

func uploadPage(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	_ = uploadTpl.Execute(w, nil)
}

// Cleanly save a multipart file to disk (kept for completeness)
func savePartToTemp(part *multipart.Part, suggested string) (string, error) {
	tmpDir := os.TempDir()
	name := filepath.Base(suggested)
	if name == "" || name == "." || name == "/" {
		name = fmt.Sprintf("upload_%d", time.Now().UnixNano())
	}
	dst := filepath.Join(tmpDir, name)
	f, err := os.Create(dst)
	if err != nil {
		return "", err
	}
	defer f.Close()
	_, err = io.Copy(f, part)
	return dst, err
}

// Parse options (after ParseMultipartForm)
func parseOpts(r *http.Request) (compressOpts, error) {
	o := compressOpts{}
	get := func(key, def string) string {
		if v := r.FormValue(key); v != "" {
			return v
		}
		return def
	}
	o.Codec = get("codec", "h264")
	o.Audio = get("audio", "aac")
	o.AB = get("ab", "")
	o.HW = get("hw", "none")
	o.OutExt = get("outExt", ".mp4")
	o.SpeedMode = get("speed", "ai")
	o.Resolution = get("resolution", "original")
	if fpsStr := get("fps", ""); fpsStr != "" {
		if n, err := strconv.Atoi(fpsStr); err == nil && n > 0 && n <= 60 {
			o.FPS = n
		}
	}
	if ts := get("target_secs", "120"); ts != "" {
		if n, err := strconv.Atoi(ts); err == nil && n > 0 {
			o.TargetSecs = n
		}
	}
	o.normalize()
	return o, nil
}

func compressHandler(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		uploadPage(w, r)
		return
	case http.MethodPost:
	default:
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}

	if err := r.ParseMultipartForm(maxUploadSize); err != nil {
		http.Error(w, "expecting multipart/form-data: "+err.Error(), http.StatusBadRequest)
		return
	}

	file, hdr, err := r.FormFile("file")
	if err != nil {
		http.Error(w, "file field required", http.StatusBadRequest)
		return
	}
	defer file.Close()

	// Save upload to temp file
	inPath := filepath.Join(os.TempDir(), filepath.Base(hdr.Filename))
	outf, err := os.Create(inPath)
	if err != nil {
		http.Error(w, "save error: "+err.Error(), 500)
		return
	}
	if _, err := io.Copy(outf, file); err != nil {
		outf.Close()
		http.Error(w, "save error: "+err.Error(), 500)
		return
	}
	outf.Close()
	defer os.Remove(inPath)

	// Parse options
	opts, err := parseOpts(r)
	if err != nil {
		http.Error(w, err.Error(), 400)
		return
	}

	// File info
	st, _ := os.Stat(inPath)
	var sizeMB int64
	var inputBytes int64
	if st != nil {
		inputBytes = st.Size()
		sizeMB = st.Size() / (1024 * 1024)
	}

	// Probe duration (seconds)
	durationSecs := probeDuration(inPath)

	// Decide final mode if AI (duration-aware)
	modeDecider := "manual"
	if opts.SpeedMode == "ai" {
		modeDecider = "ai"

		// Rule 1: Very short clips (≤60s): never force turbo/max just because size is big
		if durationSecs > 0 && durationSecs <= 60 {
			opts.SpeedMode = "balanced"
		} else if opts.TargetSecs <= 10 {
			opts.SpeedMode = "turbo"
		} else if opts.TargetSecs <= 20 {
			opts.SpeedMode = "max"
		} else {
			base := chooseSpeedBySize(sizeMB)

			// Previous size rule retained (but only if not short duration)
			if sizeMB >= 200 && sizeMB < 2048 {
				if sizeMB <= 250 && opts.TargetSecs >= 180 {
					base = "balanced"
				} else {
					base = "ultra_fast"
				}
			}

			// Pick fastest that fits target
			candidates := []string{"turbo", "max", "ultra_fast", "super_fast", "fast", "balanced", "quality"}
			chosen := ""
			for _, c := range candidates {
				if estimateTimeSecs(sizeMB, c) <= opts.TargetSecs {
					chosen = c
					break
				}
			}
			if chosen == "" {
				chosen = base
			}
			opts.SpeedMode = chosen
		}
	}

	// Small-file safety
	opts.tinyInputSafety(inputBytes)

	// Apply profile params
	opts.applySpeedMode()

	outPath := withExt(inPath, "_compressed"+opts.OutExt)

	// Estimate now that the mode is final (for reporting)
	estimated := estimateTimeSecs(sizeMB, opts.SpeedMode)

	// Run ffmpeg synchronously, measure time
	ctx, cancel := context.WithTimeout(r.Context(), opts.Timeout)
	defer cancel()

	start := time.Now()
	if err := runFFmpeg(ctx, inPath, outPath, opts, io.Discard); err != nil {
		http.Error(w, "compression failed: "+err.Error(), 500)
		return
	}
	elapsed := time.Since(start)

	// validate output
	stat, err := os.Stat(outPath)
	if err != nil || stat.Size() < 1024 {
		http.Error(w, "output seems empty or invalid", 500)
		return
	}
	outputBytes := stat.Size()

	throughput := 0.0
	sec := elapsed.Seconds()
	if sec > 0 {
		throughput = (float64(inputBytes) / (1024 * 1024)) / sec
	}

	// If API call (Accept: application/octet-stream), return FILE BYTES + metadata headers
	accept := r.Header.Get("Accept")
	if strings.Contains(accept, "application/octet-stream") || r.FormValue("api") == "1" {
		// add metadata headers
		w.Header().Set("X-Mode", opts.SpeedMode)
		w.Header().Set("X-Mode-Decider", modeDecider)
		w.Header().Set("X-Target-Secs", fmt.Sprintf("%d", opts.TargetSecs))
		w.Header().Set("X-Estimated-Secs", fmt.Sprintf("%d", estimated))
		w.Header().Set("X-Encode-Duration-Ms", fmt.Sprintf("%d", elapsed.Milliseconds()))
		w.Header().Set("X-Input-Bytes", fmt.Sprintf("%d", inputBytes))
		w.Header().Set("X-Output-Bytes", fmt.Sprintf("%d", outputBytes))
		w.Header().Set("X-Input-Duration-Secs", fmt.Sprintf("%.3f", durationSecs))
		w.Header().Set("X-Throughput-MBps", fmt.Sprintf("%.4f", throughput))
		w.Header().Set("X-Resolution", opts.Resolution)
		w.Header().Set("X-Video-Codec", opts.Codec)
		w.Header().Set("X-Audio-Codec", opts.Audio)
		w.Header().Set("X-HW", opts.HW)

		ctype := "application/octet-stream"
		switch strings.ToLower(filepath.Ext(outPath)) {
		case ".mp4":
			ctype = "video/mp4"
		case ".mov":
			ctype = "video/quicktime"
		}
		w.Header().Set("Content-Type", ctype)
		w.Header().Set("Content-Disposition", "attachment; filename=\""+filepath.Base(outPath)+"\"")
		http.ServeFile(w, r, outPath)
		return
	}

	// Otherwise, UI flow: keep file in temp store and show a result page
	id := randID(12)
	entry := &resultEntry{
		FilePath:       outPath,
		CreatedAt:      time.Now(),
		ModeFinal:      opts.SpeedMode,
		ModeDecider:    modeDecider,
		InputBytes:     inputBytes,
		InputDurationS: durationSecs,
		OutputBytes:    outputBytes,
		DurationMS:     elapsed.Milliseconds(),
		Resolution:     opts.Resolution,
		Codec:          opts.Codec,
		Audio:          opts.Audio,
		HW:             opts.HW,
		ThroughputMBs:  throughput,
		TargetSecs:     opts.TargetSecs,
		EstimatedSecs:  estimated,
	}
	storeMu.Lock()
	store[id] = entry
	storeMu.Unlock()

	// Render result HTML
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	data := map[string]any{
		"ID":            id,
		"ModeFinal":     entry.ModeFinal,
		"ModeDecider":   entry.ModeDecider,
		"Seconds":       float64(entry.DurationMS) / 1000.0,
		"Throughput":    entry.ThroughputMBs,
		"InputBytes":    entry.InputBytes,
		"OutputBytes":   entry.OutputBytes,
		"InputHuman":    humanBytes(entry.InputBytes),
		"OutputHuman":   humanBytes(entry.OutputBytes),
		"Resolution":    entry.Resolution,
		"Codec":         entry.Codec,
		"Audio":         entry.Audio,
		"HW":            entry.HW,
		"SuggestName":   filepath.Base(outPath),
		"TargetSecs":    entry.TargetSecs,
		"EstimatedSecs": entry.EstimatedSecs,
		"InputDuration": entry.InputDurationS,
	}
	_ = resultTpl.Execute(w, data)
}

func dlHandler(w http.ResponseWriter, r *http.Request) {
	id := strings.TrimPrefix(r.URL.Path, "/dl/")
	storeMu.Lock()
	e, ok := store[id]
	storeMu.Unlock()
	if !ok {
		http.NotFound(w, r)
		return
	}
	name := r.URL.Query().Get("name")
	if name == "" {
		name = filepath.Base(e.FilePath)
	}
	ctype := "application/octet-stream"
	switch strings.ToLower(filepath.Ext(name)) {
	case ".mp4":
		ctype = "video/mp4"
	case ".mov":
		ctype = "video/quicktime"
	}
	w.Header().Set("Content-Type", ctype)
	w.Header().Set("Content-Disposition", "attachment; filename=\""+name+"\"")
	http.ServeFile(w, r, e.FilePath)
}

func metaHandler(w http.ResponseWriter, r *http.Request) {
	id := strings.TrimPrefix(r.URL.Path, "/meta/")
	storeMu.Lock()
	e, ok := store[id]
	storeMu.Unlock()
	if !ok {
		http.NotFound(w, r)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(map[string]any{
		"id":                 id,
		"mode":               e.ModeFinal,
		"mode_decider":       e.ModeDecider,
		"duration_ms":        e.DurationMS,
		"target_secs":        e.TargetSecs,
		"estimated_secs":     e.EstimatedSecs,
		"input_bytes":        e.InputBytes,
		"input_duration_sec": e.InputDurationS,
		"output_bytes":       e.OutputBytes,
		"throughput_mb_s":    e.ThroughputMBs,
		"resolution":         e.Resolution,
		"codec":              e.Codec,
		"audio":              e.Audio,
		"hw":                 e.HW,
		"created_at":         e.CreatedAt.Format(time.RFC3339),
	})
}

func health(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(map[string]any{
		"ok":        true,
		"service":   "videocompress",
		"version":   "2.8.0",
		"modes":     []string{"ai", "turbo", "max", "ultra_fast", "super_fast", "fast", "balanced", "quality"},
		"defaults":  map[string]any{"codec": "h264", "resolution": "original", "hw": "none", "target_secs": 120},
		"ui_routes": []string{"/", "/compress (POST)", "/dl/{id}", "/meta/{id}"},
	})
}

func main() {
	go cleanupStore()

	addr := envOr("PORT", "8080")

	mux := http.NewServeMux()
	mux.HandleFunc("/", uploadPage)
	mux.HandleFunc("/compress", compressHandler)
	mux.HandleFunc("/dl/", dlHandler)     // GET /dl/{id}?name=...
	mux.HandleFunc("/meta/", metaHandler) // GET /meta/{id}
	mux.HandleFunc("/health", health)

	s := &http.Server{
		Addr:              ":" + addr,
		Handler:           logMiddleware(mux),
		ReadHeaderTimeout: 20 * time.Second,
	}

	log.Printf("VideoCompress server listening on http://localhost:%s ...", addr)
	if err := s.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
		log.Fatal(err)
	}
}

// basic request logger
func logMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		next.ServeHTTP(w, r)
		log.Printf("%s %s %s", r.Method, r.URL.Path, time.Since(start))
	})
}

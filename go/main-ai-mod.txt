package main

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"html/template"
	"io"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

// ======================
// Config
// ======================

const (
	maxUploadSize = 2 << 30 // 2 GB
)

// ======================
// Helpers
// ======================

func envOr(k, def string) string {
	if v := os.Getenv(k); v != "" {
		return v
	}
	return def
}

func withExt(p, newExt string) string {
	base := strings.TrimSuffix(filepath.Base(p), filepath.Ext(p))
	return filepath.Join(filepath.Dir(p), base+newExt)
}

// ======================
// Encoding options + logic
// ======================

type compressOpts struct {
	Codec      string        // h264|h265|copy
	CRF        int           // CPU encoders quality
	Preset     string        // ultrafast..placebo (CPU encoders)
	Scale      string        // e.g. 1280:-2 or 1920:1080
	Audio      string        // aac|opus|copy
	AB         string        // audio bitrate
	HW         string        // videotoolbox|none
	OutExt     string        // .mp4 (recommended)
	Timeout    time.Duration // overall job timeout
	SpeedMode  string        // ultra_fast|super_fast|fast|balanced|quality|ai
	Resolution string        // 360p|480p|720p|1080p|1440p|2160p|original
	TargetSecs int           // AI time budget in seconds (default 120)
}

func (o *compressOpts) normalize() {
	if o.Codec == "" {
		o.Codec = "h264"
	}
	if o.Audio == "" {
		o.Audio = "aac"
	}
	if o.AB == "" {
		o.AB = "128k"
	}
	if o.HW == "" {
		o.HW = "none" // VPS-safe default
	}
	if o.OutExt == "" {
		o.OutExt = ".mp4"
	}
	if o.Timeout == 0 {
		o.Timeout = 45 * time.Minute
	}
	if o.SpeedMode == "" {
		o.SpeedMode = "ai"
	}
	if o.Resolution == "" {
		o.Resolution = "original"
	}
	if o.TargetSecs <= 0 {
		o.TargetSecs = 120 // default 2 minutes
	}
	// NOTE: applySpeedMode will be called AFTER AI logic finalizes SpeedMode.
	o.applyResolution()
}

// Throughput model (very rough MB/s per mode).
// Adjust for your hardware if needed.
func throughputMBps(speed string) float64 {
	switch speed {
	case "ultra_fast":
		return 8.0
	case "super_fast":
		return 5.0
	case "fast":
		return 3.0
	case "balanced":
		return 2.0
	case "quality":
		return 1.2
	default:
		return 2.0
	}
}

// Estimate time by size & profile (seconds)
func estimateTimeSecs(sizeMB int64, speed string) int {
	t := throughputMBps(speed)
	if t <= 0 {
		t = 2.0
	}
	secs := float64(sizeMB) / t
	// add small overhead
	secs *= 1.15
	return int(secs)
}

func chooseSpeedBySize(sizeMB int64) string {
	switch {
	case sizeMB >= 700:
		return "ultra_fast"
	case sizeMB >= 200:
		return "super_fast"
	case sizeMB >= 50:
		return "fast"
	case sizeMB >= 10:
		return "balanced"
	default:
		return "balanced"
	}
}

// Apply speed profile → updates CRF/Preset/AB
func (o *compressOpts) applySpeedMode() {
	switch o.SpeedMode {
	case "ultra_fast":
		o.CRF = 32
		o.Preset = "ultrafast"
		o.AB = "96k"
	case "super_fast":
		o.CRF = 30
		o.Preset = "ultrafast"
		o.AB = "96k"
	case "fast":
		o.CRF = 28
		o.Preset = "veryfast"
		o.AB = "128k"
	case "quality":
		o.CRF = 23
		o.Preset = "fast"
		o.AB = "128k"
	default: // balanced
		if o.CRF == 0 {
			o.CRF = 26
		}
		if o.Preset == "" {
			o.Preset = "veryfast"
		}
	}
}

func (o *compressOpts) applyResolution() {
	switch o.Resolution {
	case "360p":
		o.Scale = "640:360"
	case "480p":
		o.Scale = "854:480"
	case "720p":
		o.Scale = "1280:720"
	case "1080p":
		o.Scale = "1920:1080"
	case "1440p":
		o.Scale = "2560:1440"
	case "2160p":
		o.Scale = "3840:2160"
	case "original":
		// keep original
	default:
		// unknown -> keep original
	}
}

// Extra safety for very small inputs
func (o *compressOpts) tinyInputSafety(fileSize int64) {
	sizeMB := fileSize / (1024 * 1024)
	if sizeMB < 10 {
		o.Codec = "h264"
		o.Audio = "aac"
		o.Scale = ""
		o.CRF = 22
		o.Preset = "veryfast"
		o.HW = "none"
	}
}

// Translate options → ffmpeg args
func buildFFmpegArgs(inPath, outPath string, o compressOpts) []string {
	args := []string{"-y", "-hide_banner", "-loglevel", "error", "-i", inPath}

	// scale
	if o.Scale != "" && strings.ToLower(o.Codec) != "copy" {
		args = append(args, "-vf", "scale="+o.Scale+":flags=fast_bilinear")
	}

	// codec
	vcodec := ""
	switch strings.ToLower(o.Codec) {
	case "copy":
		vcodec = "copy"
	case "h265":
		if strings.ToLower(o.HW) == "videotoolbox" {
			vcodec = "hevc_videotoolbox"
		} else {
			vcodec = "libx265"
		}
	default: // h264
		if strings.ToLower(o.HW) == "videotoolbox" {
			vcodec = "h264_videotoolbox"
		} else {
			vcodec = "libx264"
		}
	}

	if vcodec == "copy" {
		args = append(args, "-c:v", "copy")
	} else {
		args = append(args, "-c:v", vcodec)

		switch vcodec {
		case "libx264", "libx265":
			args = append(args, "-crf", strconv.Itoa(o.CRF), "-preset", o.Preset)
		case "h264_videotoolbox", "hevc_videotoolbox":
			// map CRF→bitrate for hardware encoders
			bitrate := "3M"
			switch {
			case o.CRF <= 20:
				bitrate = "5M"
			case o.CRF <= 23:
				bitrate = "4M"
			case o.CRF <= 26:
				bitrate = "3M"
			case o.CRF <= 30:
				bitrate = "2.5M"
			default:
				bitrate = "2M"
			}
			args = append(args, "-b:v", bitrate)
		}

		// browser compatibility
		if strings.ToLower(o.OutExt) == ".mp4" {
			args = append(args, "-pix_fmt", "yuv420p")
		}
	}

	// audio
	switch strings.ToLower(o.Audio) {
	case "copy":
		args = append(args, "-c:a", "copy")
	case "opus":
		args = append(args, "-c:a", "libopus", "-b:a", o.AB)
	default:
		args = append(args, "-c:a", "aac", "-b:a", o.AB)
	}

	// play nice on the web
	args = append(args, "-movflags", "+faststart", "-threads", "0", outPath)
	return args
}

// run ffmpeg synchronously; if HW fails, retry CPU
func runFFmpeg(ctx context.Context, inPath, outPath string, o compressOpts, logWriter io.Writer) error {
	o.normalize()
	args := buildFFmpegArgs(inPath, outPath, o)

	cmd := exec.CommandContext(ctx, "ffmpeg", args...)
	cmd.Stdout = logWriter
	cmd.Stderr = logWriter
	err := cmd.Run()
	if err == nil {
		return nil
	}

	if strings.Contains(strings.ToLower(o.HW), "videotoolbox") {
		fmt.Fprintln(logWriter, "VideoToolbox failed; falling back to CPU.")
		o.HW = "none"
		args = buildFFmpegArgs(inPath, outPath, o)
		cmd = exec.CommandContext(ctx, "ffmpeg", args...)
		cmd.Stdout = logWriter
		cmd.Stderr = logWriter
		return cmd.Run()
	}
	return err
}

// ======================
//
// HTTP layer
//
// ======================

var uploadTpl = template.Must(template.New("u").Parse(`
<!doctype html>
<meta charset="utf-8">
<title>Video Compress</title>
<style>
body{font-family:ui-sans-serif,system-ui;margin:40px;max-width:800px;line-height:1.6}
.form-group{margin:12px 0}
label{display:block;margin-bottom:6px;font-weight:600}
input,select{width:100%;padding:8px;border:1px solid #d1d5db;border-radius:6px}
button{background:#111827;color:#fff;border:0;padding:12px 20px;border-radius:8px;cursor:pointer}
button:hover{background:#0f172a}
details{margin:12px 0}
pre{background:#f3f4f6;padding:12px;border-radius:6px;overflow:auto}
.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:8px}
.card{border:1px solid #e5e7eb;border-radius:8px;padding:8px}
.card input{width:auto}
small{color:#6b7280}
</style>

<h1>Video Compress</h1>

<form method="post" action="/compress" enctype="multipart/form-data">
  <div class="form-group">
    <label>Video file</label>
    <input type="file" name="file" accept="video/*" required>
  </div>

  <div class="grid">
    <div class="card">
      <label>Mode</label>
      <select name="speed">
        <option value="ai" selected>AI (auto by size & time)</option>
        <option value="balanced">Balanced</option>
        <option value="fast">Fast</option>
        <option value="super_fast">Super Fast</option>
        <option value="ultra_fast">Ultra Fast</option>
        <option value="quality">Quality</option>
      </select>
      <small>AI picks speed by file size + your time budget.</small>
    </div>
    <div class="card">
      <label>Time budget (seconds)</label>
      <input type="number" name="target_secs" value="120" min="30" step="10">
      <small>Example: 120 = 2 minutes</small>
    </div>
    <div class="card">
      <label>Resolution</label>
      <select name="resolution">
        <option value="original" selected>Original</option>
        <option value="360p">360p</option>
        <option value="480p">480p</option>
        <option value="720p">720p</option>
        <option value="1080p">1080p</option>
        <option value="1440p">1440p</option>
        <option value="2160p">2160p</option>
      </select>
    </div>
  </div>

  <details>
    <summary>Advanced</summary>
    <div class="grid">
      <div class="card">
        <label>Video codec</label>
        <select name="codec">
          <option value="h264" selected>H.264</option>
          <option value="h265">H.265/HEVC</option>
          <option value="copy">Copy video stream</option>
        </select>
      </div>
      <div class="card">
        <label>Hardware</label>
        <select name="hw">
          <option value="none" selected>CPU only</option>
          <option value="videotoolbox">macOS VideoToolbox</option>
        </select>
      </div>
      <div class="card">
        <label>Audio codec</label>
        <select name="audio">
          <option value="aac" selected>AAC</option>
          <option value="opus">Opus</option>
          <option value="copy">Copy audio</option>
        </select>
      </div>
      <div class="card">
        <label>Output extension</label>
        <select name="outExt">
          <option value=".mp4" selected>.mp4</option>
          <option value=".mov">.mov</option>
        </select>
      </div>
    </div>
  </details>

  <button type="submit">Compress</button>
</form>

<h3>cURL example</h3>
<pre>
# AI mode, 2-minute budget
curl -F "file=@input.mp4" -F "speed=ai" -F "target_secs=120" http://localhost:8080/compress -o out.mp4
</pre>
`))

func uploadPage(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	_ = uploadTpl.Execute(w, nil)
}

// Cleanly save a multipart file to disk (unused path, kept for reference)
func savePartToTemp(part *multipart.Part, suggested string) (string, error) {
	tmpDir := os.TempDir()
	name := filepath.Base(suggested)
	if name == "" || name == "." || name == "/" {
		name = fmt.Sprintf("upload_%d", time.Now().UnixNano())
	}
	dst := filepath.Join(tmpDir, name)
	f, err := os.Create(dst)
	if err != nil {
		return "", err
	}
	defer f.Close()
	_, err = io.Copy(f, part)
	return dst, err
}

// Parse options (after ParseMultipartForm)
func parseOpts(r *http.Request) (compressOpts, error) {
	o := compressOpts{}
	get := func(key, def string) string {
		if v := r.FormValue(key); v != "" {
			return v
		}
		return def
	}
	o.Codec = get("codec", "h264")
	o.Audio = get("audio", "aac")
	o.AB = get("ab", "")
	o.HW = get("hw", "none")
	o.OutExt = get("outExt", ".mp4")
	o.SpeedMode = get("speed", "ai")
	o.Resolution = get("resolution", "original")
	if ts := get("target_secs", "120"); ts != "" {
		if n, err := strconv.Atoi(ts); err == nil && n > 0 {
			o.TargetSecs = n
		}
	}
	o.normalize()
	return o, nil
}

func compressHandler(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		uploadPage(w, r)
		return
	case http.MethodPost:
	default:
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}

	if err := r.ParseMultipartForm(maxUploadSize); err != nil {
		http.Error(w, "expecting multipart/form-data: "+err.Error(), http.StatusBadRequest)
		return
	}

	file, hdr, err := r.FormFile("file")
	if err != nil {
		http.Error(w, "file field required", http.StatusBadRequest)
		return
	}
	defer file.Close()

	// Save upload to temp file
	inPath := filepath.Join(os.TempDir(), filepath.Base(hdr.Filename))
	out, err := os.Create(inPath)
	if err != nil {
		http.Error(w, "save error: "+err.Error(), 500)
		return
	}
	if _, err := io.Copy(out, file); err != nil {
		out.Close()
		http.Error(w, "save error: "+err.Error(), 500)
		return
	}
	out.Close()
	defer os.Remove(inPath)

	// Parse options
	opts, err := parseOpts(r)
	if err != nil {
		http.Error(w, err.Error(), 400)
		return
	}

	// File info
	st, _ := os.Stat(inPath)
	sizeMB := int64(0)
	if st != nil {
		sizeMB = st.Size() / (1024 * 1024)
	}

	// AI mode: decide speed by size + time budget
	if opts.SpeedMode == "ai" {
		// Base choice by size first
		base := chooseSpeedBySize(sizeMB)

		// Special rule (your request):
		// For 200MB–2GB prefer ultra_fast,
		// BUT if ~200–250MB and target_secs >= 180, don't force ultra_fast.
		if sizeMB >= 200 && sizeMB < 2048 {
			if sizeMB <= 250 && opts.TargetSecs >= 180 {
				base = "balanced"
			} else {
				base = "ultra_fast"
			}
		}

		// Try to pick the fastest mode that satisfies the time budget.
		// Order fastest→slower.
		candidates := []string{"ultra_fast", "super_fast", "fast", "balanced", "quality"}

		var chosen string
		for _, c := range candidates {
			est := estimateTimeSecs(sizeMB, c)
			if est <= opts.TargetSecs {
				chosen = c
				break
			}
		}
		if chosen == "" {
			// None meet the time budget; use the base (usually fastest).
			chosen = base
		}
		opts.SpeedMode = chosen
	}

	// Small-file safety
	opts.tinyInputSafety(st.Size())

	// Apply profile params
	opts.applySpeedMode()

	outPath := withExt(inPath, "_compressed"+opts.OutExt)

	ctx, cancel := context.WithTimeout(r.Context(), opts.Timeout)
	defer cancel()

	if err := runFFmpeg(ctx, inPath, outPath, opts, io.Discard); err != nil {
		http.Error(w, "compression failed: "+err.Error(), 500)
		return
	}

	// validate output
	stat, err := os.Stat(outPath)
	if err != nil || stat.Size() < 1024 {
		http.Error(w, "output seems empty or invalid", 500)
		return
	}

	// serve file
	ctype := "application/octet-stream"
	switch strings.ToLower(filepath.Ext(outPath)) {
	case ".mp4":
		ctype = "video/mp4"
	case ".mov":
		ctype = "video/quicktime"
	}
	w.Header().Set("Content-Type", ctype)
	w.Header().Set("Content-Disposition", "attachment; filename=\""+filepath.Base(outPath)+"\"")
	http.ServeFile(w, r, outPath)
}

func health(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(map[string]any{
		"ok":        true,
		"service":   "videocompress",
		"version":   "2.3.0",
		"modes":     []string{"ai", "balanced", "fast", "super_fast", "ultra_fast", "quality"},
		"time_hint": "AI picks the fastest profile that fits target_secs; 200MB–2GB prefers ultra_fast unless ~200–250MB with >=180s budget.",
		"defaults":  map[string]any{"codec": "h264", "resolution": "original", "hw": "none", "target_secs": 120},
	})
}

func main() {
	addr := envOr("PORT", "8080")

	mux := http.NewServeMux()
	mux.HandleFunc("/", uploadPage)
	mux.HandleFunc("/compress", compressHandler)
	mux.HandleFunc("/health", health)

	s := &http.Server{
		Addr:              ":" + addr,
		Handler:           logMiddleware(mux),
		ReadHeaderTimeout: 20 * time.Second,
	}

	log.Printf("VideoCompress server listening on http://localhost:%s ...", addr)
	if err := s.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
		log.Fatal(err)
	}
}

// basic request logger
func logMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		next.ServeHTTP(w, r)
		log.Printf("%s %s %s", r.Method, r.URL.Path, time.Since(start))
	})
}
